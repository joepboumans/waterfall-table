version:
  version: 1.0.1
  run_id: "609d14c6f1544a25"
  target: Tofino
phv ingress:
  ig_intr_md.resubmit_flag: {  stage 0..9: H1(15) } 
  ig_intr_md.ingress_port: {  stage 0: H1(0..8) } 
  hdr.ethernet.dst_addr.0-7: TB4
  hdr.ethernet.dst_addr.8-15: TB5
  hdr.ethernet.dst_addr.16-23: TB6
  hdr.ethernet.dst_addr.24-31: TB7
  hdr.ethernet.dst_addr.32-47: TH14
  hdr.ethernet.src_addr.0-15: TH10
  hdr.ethernet.src_addr.16-31: TH11
  hdr.ethernet.src_addr.32-47: TH13
  hdr.ethernet.ether_type: TH12
  hdr.ipv4.version: TW4(28..31)
  hdr.ipv4.ihl: TW4(24..27)
  hdr.ipv4.diffserv: TW4(16..23)
  hdr.ipv4.total_len: TW4(0..15)
  hdr.ipv4.identification: TW7(16..31)
  hdr.ipv4.flags: TW7(13..15)
  hdr.ipv4.frag_offset: TW7(0..12)
  hdr.ipv4.ttl: TW6(24..31)
  hdr.ipv4.protocol: TW6(16..23)
  hdr.ipv4.hdr_checksum: TW6(0..15)
  hdr.ipv4.src_addr: W0
  hdr.ipv4.dst_addr: TW8
  hdr.udp.src_port: TH7
  hdr.udp.dst_port: TH6
  hdr.udp.hdr_length: TW5(16..31)
  hdr.udp.checksum: TW5(0..15)
  hdr.tcp.src_port: TH9
  hdr.tcp.dst_port: TH8
  hdr.tcp.seq_no: TW10
  hdr.tcp.ack_no: TW9
  hdr.tcp.data_offset: TW5(28..31)
  hdr.tcp.res: TW5(24..27)
  hdr.tcp.flags: TW5(16..23)
  hdr.tcp.window: TW5(0..15)
  hdr.tcp.checksum: TH7
  hdr.tcp.urgent_ptr: TH6
  ig_md.resubmit_md.type: B5
  ig_md.resubmit_md.remain: W3
  ig_intr_md_for_tm.ucast_egress_port: {  stage 1..12: H0(0..8) } 
  ig_md.found_hi: {  stage 1..9: B4(3) } 
  ig_md.found_lo: {  stage 1..9: B4(4) } 
  ig_md.remain1_hi: {  stage 2..4: W4(0..15) } 
  ig_md.remain1_lo: {  stage 3..4: W1(0..15) } 
  ig_md.remain2_hi: {  stage 4..6: W5(0..15) } 
  ig_md.remain2_lo: {  stage 5..6: W2(0..15) } 
  ig_md.remain3_hi: {  stage 6..8: W4(0..15) } 
  ig_md.remain3_lo: {  stage 7..8: W1(0..15) } 
  ig_intr_md_for_dprsr.drop_ctl: {  stage 1..12: B4(0..2) } 
  ig_intr_md_for_dprsr.digest_type: {  stage 10..12: B1(0..2) } 
  ig_intr_md_for_dprsr.resubmit_type: {  stage 10..12: B2(0..2) } 
  ig_intr_md_for_dprsr.mirror_type: {  stage 12: B3(0..2) } 
  $tmp2: {  stage 12: H1(0..9) } 
  $tmp3.0-7: {  stage 12: B0 } 
  $tmp3.8-15: {  stage 12: B0 } 
  $tmp3.16-23: {  stage 12: B0 } 
  hdr.ethernet.$valid: B6(0)
  hdr.ipv4.$valid: B6(1)
  hdr.udp.$valid: B6(2)
  hdr.tcp.$valid: B6(3)
  context_json:
    B0:
    - { name : $tmp3, live_start : deparser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : $tmp3, live_start : deparser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : $tmp3, live_start : deparser, live_end : deparser, mutually_exclusive_with: [  ] }
    B1:
    - { name : ig_intr_md_for_dprsr.digest_type, live_start : 10, live_end : deparser, mutually_exclusive_with: [  ] }
    B2:
    - { name : ig_intr_md_for_dprsr.resubmit_type, live_start : 10, live_end : deparser, mutually_exclusive_with: [  ] }
    B3:
    - { name : ig_intr_md_for_dprsr.mirror_type, live_start : deparser, live_end : deparser, mutually_exclusive_with: [  ] }
    B4:
    - { name : ig_md.found_hi, live_start : 1, live_end : 9, mutually_exclusive_with: [  ] }
    - { name : ig_md.found_lo, live_start : 1, live_end : 9, mutually_exclusive_with: [  ] }
    - { name : ig_intr_md_for_dprsr.drop_ctl, live_start : 1, live_end : deparser, mutually_exclusive_with: [  ] }
    B5:
    - { name : ig_md.resubmit_md.type, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    B6:
    - { name : hdr.ethernet.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.ipv4.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.udp.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.tcp.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    H0:
    - { name : ig_intr_md_for_tm.ucast_egress_port, live_start : 1, live_end : deparser, mutually_exclusive_with: [  ] }
    H1:
    - { name : ig_intr_md.resubmit_flag, live_start : parser, live_end : 9, mutually_exclusive_with: [  ] }
    - { name : ig_intr_md.ingress_port, live_start : parser, live_end : 0, mutually_exclusive_with: [  ] }
    - { name : $tmp2, live_start : deparser, live_end : deparser, mutually_exclusive_with: [  ] }
    W0:
    - { name : hdr.ipv4.src_addr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    W1:
    - { name : ig_md.remain1_lo, live_start : 3, live_end : 4, mutually_exclusive_with: [  ] }
    - { name : ig_md.remain3_lo, live_start : 7, live_end : 8, mutually_exclusive_with: [  ] }
    W2:
    - { name : ig_md.remain2_lo, live_start : 5, live_end : 6, mutually_exclusive_with: [  ] }
    W3:
    - { name : ig_md.resubmit_md.remain, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    W4:
    - { name : ig_md.remain1_hi, live_start : 2, live_end : 4, mutually_exclusive_with: [  ] }
    - { name : ig_md.remain3_hi, live_start : 6, live_end : 8, mutually_exclusive_with: [  ] }
    W5:
    - { name : ig_md.remain2_hi, live_start : 4, live_end : 6, mutually_exclusive_with: [  ] }
phv egress:
  hdr.min_parse_depth_padding_0$0.packet_payload.0-31: TW3
  hdr.min_parse_depth_padding_0$0.packet_payload.32-47: TH0
  hdr.min_parse_depth_padding_0$0.packet_payload.48-63: TH1
  hdr.min_parse_depth_padding_0$0.packet_payload.64-71: TB3
  hdr.min_parse_depth_padding_0$0.packet_payload.72-79: TB12
  hdr.min_parse_depth_padding_0$0.packet_payload.80-87: TB0
  hdr.min_parse_depth_padding_0$1.packet_payload.0-15: TH2
  hdr.min_parse_depth_padding_0$1.packet_payload.16-31: TH3
  hdr.min_parse_depth_padding_0$1.packet_payload.32-47: TH4
  hdr.min_parse_depth_padding_0$1.packet_payload.48-63: TH5
  hdr.min_parse_depth_padding_0$1.packet_payload.64-79: TH20
  hdr.min_parse_depth_padding_0$1.packet_payload.80-87: TB1
  hdr.min_parse_depth_padding_0$2.packet_payload.0-31: TW12
  hdr.min_parse_depth_padding_0$2.packet_payload.32-63: TW13
  hdr.min_parse_depth_padding_0$2.packet_payload.64-79: TH21
  hdr.min_parse_depth_padding_0$2.packet_payload.80-87: TB2
  eg_intr_md.egress_port: H16(0..8)
  hdr.ethernet.dst_addr.0-31: TW15
  hdr.ethernet.dst_addr.32-39: TB13
  hdr.ethernet.dst_addr.40-47: TB14
  hdr.ethernet.src_addr.0-31: TW14
  hdr.ethernet.src_addr.32-47: TH23
  hdr.ethernet.ether_type: TH22
  hdr.ipv4.version: TW0(28..31)
  hdr.ipv4.ihl: TW0(24..27)
  hdr.ipv4.diffserv: TW0(16..23)
  hdr.ipv4.total_len: TW0(0..15)
  hdr.ipv4.identification: TW2(16..31)
  hdr.ipv4.flags: TW2(13..15)
  hdr.ipv4.frag_offset: TW2(0..12)
  hdr.ipv4.ttl: TW1(24..31)
  hdr.ipv4.protocol: TW1(16..23)
  hdr.ipv4.hdr_checksum: TW1(0..15)
  hdr.ipv4.src_addr: W20
  hdr.ipv4.dst_addr.0-15: TH18
  hdr.ipv4.dst_addr.16-31: TH19
  hdr.tcp.src_port: TH1
  hdr.tcp.dst_port: TH0
  hdr.tcp.seq_no: TW13
  hdr.tcp.ack_no: TW12
  hdr.tcp.data_offset: TB2(4..7)
  hdr.tcp.res: TB2(0..3)
  hdr.tcp.flags: TB3
  hdr.tcp.window.0-7: TB0
  hdr.tcp.window.8-15: TB1
  hdr.tcp.checksum: TW3(16..31)
  hdr.tcp.urgent_ptr: TW3(0..15)
  hdr.udp.src_port: TH1
  hdr.udp.dst_port: TH0
  hdr.udp.hdr_length: TW3(16..31)
  hdr.udp.checksum: TW3(0..15)
  eg_md.hash_meta_d1: {  stage 1..4: W21 } 
  eg_md.hash_meta_d2: {  stage 1..4: W22 } 
  eg_md.result_d1: {  stage 3..4: W16 } 
  eg_md.result_d2: {  stage 2..4: W18 } 
  $tmp44: {  stage 1..3: W17 } 
  $tmp45: {  stage 1..3: W19 } 
  hdr.ethernet.$valid: B17(0)
  hdr.ipv4.$valid: B17(1)
  hdr.tcp.$valid: B17(2)
  hdr.udp.$valid: B17(3)
  hdr.min_parse_depth_padding_0.$stkvalid: B16(0..2)
  hdr.min_parse_depth_padding_0$0.$valid: B16(2)
  hdr.min_parse_depth_padding_0$1.$valid: B16(1)
  hdr.min_parse_depth_padding_0$2.$valid: B16(0)
  context_json:
    B16:
    - { name : hdr.min_parse_depth_padding_0$2.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.min_parse_depth_padding_0.$stkvalid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.min_parse_depth_padding_0$0.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.min_parse_depth_padding_0$1.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    B17:
    - { name : hdr.ethernet.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.ipv4.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.tcp.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.udp.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    H16:
    - { name : eg_intr_md.egress_port, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    W16:
    - { name : eg_md.result_d1, live_start : 3, live_end : 4, mutually_exclusive_with: [  ] }
    W17:
    - { name : $tmp44, live_start : 1, live_end : 3, mutually_exclusive_with: [  ] }
    W18:
    - { name : eg_md.result_d2, live_start : 2, live_end : 4, mutually_exclusive_with: [  ] }
    W19:
    - { name : $tmp45, live_start : 1, live_end : 3, mutually_exclusive_with: [  ] }
    W20:
    - { name : hdr.ipv4.src_addr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    W21:
    - { name : eg_md.hash_meta_d1, live_start : 1, live_end : 4, mutually_exclusive_with: [  ] }
    W22:
    - { name : eg_md.hash_meta_d2, live_start : 1, live_end : 4, mutually_exclusive_with: [  ] }
parser ingress:
  start: $entry_point
  init_zero: [ B4, W4, W1, W5, W2, B3, B0, B6, B0 ]
  bitwise_or: [ B6 ]
  hdr_len_adj: 16
  states:
    $entry_point:
      *:
        load: { byte1 : 0 }
        buf_req: 1
        next: start
    start:
      match: [ byte1 ]
      0b0*******:
        0..1: H1
            # - bit[0] -> H1 bit[15]: ingress::ig_intr_md.resubmit_flag
            # - bit[7..15] -> H1 bit[8..0]: ingress::ig_intr_md.ingress_port
        shift: 16
        buf_req: 16
        next: parse_ethernet
      0b1*******:
        0..1: H1
            # - bit[0] -> H1 bit[15]: ingress::ig_intr_md.resubmit_flag
            # - bit[7..15] -> H1 bit[8..0]: ingress::ig_intr_md.ingress_port
        shift: 8
        buf_req: 8
        next: parse_resubmit
    parse_ethernet:
      *:
        0..1: TH14  # ingress::hdr.ethernet.dst_addr[47:32].32-47
        2: TB7  # ingress::hdr.ethernet.dst_addr[31:24].24-31
        3: TB6  # ingress::hdr.ethernet.dst_addr[23:16].16-23
        4: TB5  # ingress::hdr.ethernet.dst_addr[15:8].8-15
        5: TB4  # ingress::hdr.ethernet.dst_addr[7:0].0-7
        6..7: TH13  # ingress::hdr.ethernet.src_addr[47:32].32-47
        8..9: TH11  # ingress::hdr.ethernet.src_addr[31:16].16-31
        10..11: TH10  # ingress::hdr.ethernet.src_addr[15:0].0-15
        load: { half : 12..13 }
        shift: 12
        buf_req: 14
        next: parse_ethernet.$split_0
    parse_ethernet.$split_0:
      match: [ half ]
      0x0800:
        0..1: TH12  # ingress::hdr.ethernet.ether_type
        B6: 1  # value 1 -> B6 bit[0]: ingress::hdr.ethernet.$valid
        shift: 2
        buf_req: 2
        next: parse_ipv4
      0x****:
        0..1: TH12  # ingress::hdr.ethernet.ether_type
        B6: 1  # value 1 -> B6 bit[0]: ingress::hdr.ethernet.$valid
        shift: 2
        buf_req: 2
        next: end
    parse_ipv4:
      *:
        0..3: TW4
            # - bit[0..3] -> TW4 bit[31..28]: ingress::hdr.ipv4.version
            # - bit[4..7] -> TW4 bit[27..24]: ingress::hdr.ipv4.ihl
            # - bit[8..15] -> TW4 bit[23..16]: ingress::hdr.ipv4.diffserv
            # - bit[16..31] -> TW4 bit[15..0]: ingress::hdr.ipv4.total_len
        4..7: TW7
            # - bit[32..47] -> TW7 bit[31..16]: ingress::hdr.ipv4.identification
            # - bit[48..50] -> TW7 bit[15..13]: ingress::hdr.ipv4.flags
            # - bit[51..63] -> TW7 bit[12..0]: ingress::hdr.ipv4.frag_offset
        8..11: TW6
            # - bit[64..71] -> TW6 bit[31..24]: ingress::hdr.ipv4.ttl
            # - bit[72..79] -> TW6 bit[23..16]: ingress::hdr.ipv4.protocol
            # - bit[80..95] -> TW6 bit[15..0]: ingress::hdr.ipv4.hdr_checksum
        12..15: W0  # ingress::hdr.ipv4.src_addr
        B6: 2  # value 1 -> B6 bit[1]: ingress::hdr.ipv4.$valid
        load: { byte1 : 9 }
        shift: 16
        buf_req: 16
        next: parse_ipv4.$split_0
    parse_ipv4.$split_0:
      match: [ byte1 ]
      0x11:
        0..3: TW8  # ingress::hdr.ipv4.dst_addr
        shift: 4
        buf_req: 4
        next: parse_udp
      0x06:
        0..3: TW8  # ingress::hdr.ipv4.dst_addr
        shift: 4
        buf_req: 4
        next: parse_tcp
      0x**:
        0..3: TW8  # ingress::hdr.ipv4.dst_addr
        shift: 4
        buf_req: 4
        next: end
    parse_udp:
      *:
        0..1: TH7  # ingress::hdr.udp.src_port
        2..3: TH6  # ingress::hdr.udp.dst_port
        4..7: TW5
            # - bit[32..47] -> TW5 bit[31..16]: ingress::hdr.udp.hdr_length
            # - bit[48..63] -> TW5 bit[15..0]: ingress::hdr.udp.checksum
        B6: 4  # value 1 -> B6 bit[2]: ingress::hdr.udp.$valid
        shift: 8
        buf_req: 8
        next: end
    parse_tcp:
      *:
        0..1: TH9  # ingress::hdr.tcp.src_port
        2..3: TH8  # ingress::hdr.tcp.dst_port
        4..7: TW10  # ingress::hdr.tcp.seq_no
        8..11: TW9  # ingress::hdr.tcp.ack_no
        12..15: TW5
            # - bit[96..99] -> TW5 bit[31..28]: ingress::hdr.tcp.data_offset
            # - bit[100..103] -> TW5 bit[27..24]: ingress::hdr.tcp.res
            # - bit[104..111] -> TW5 bit[23..16]: ingress::hdr.tcp.flags
            # - bit[112..127] -> TW5 bit[15..0]: ingress::hdr.tcp.window
        16..17: TH7  # ingress::hdr.tcp.checksum
        18..19: TH6  # ingress::hdr.tcp.urgent_ptr
        B6: 8  # value 1 -> B6 bit[3]: ingress::hdr.tcp.$valid
        shift: 20
        buf_req: 20
        next: end
    parse_resubmit:
      *:
        0: B5  # ingress::ig_md.resubmit_md.type
        1..4: W3  # ingress::ig_md.resubmit_md.remain
        shift: 8
        buf_req: 8
        next: parse_ethernet
deparser ingress:
  dictionary:
    TH14: B6(0)  # ingress::hdr.ethernet.dst_addr.32-47 if ingress::hdr.ethernet.$valid
    TB7: B6(0)  # ingress::hdr.ethernet.dst_addr.24-31 if ingress::hdr.ethernet.$valid
    TB6: B6(0)  # ingress::hdr.ethernet.dst_addr.16-23 if ingress::hdr.ethernet.$valid
    TB5: B6(0)  # ingress::hdr.ethernet.dst_addr.8-15 if ingress::hdr.ethernet.$valid
    TB4: B6(0)  # ingress::hdr.ethernet.dst_addr.0-7 if ingress::hdr.ethernet.$valid
    TH13: B6(0)  # ingress::hdr.ethernet.src_addr.32-47 if ingress::hdr.ethernet.$valid
    TH11: B6(0)  # ingress::hdr.ethernet.src_addr.16-31 if ingress::hdr.ethernet.$valid
    TH10: B6(0)  # ingress::hdr.ethernet.src_addr.0-15 if ingress::hdr.ethernet.$valid
    TH12: B6(0)  # ingress::hdr.ethernet.ether_type if ingress::hdr.ethernet.$valid
    TW4: B6(1)
        # - bit[31..28]: ingress::hdr.ipv4.version if ingress::hdr.ipv4.$valid
        # - bit[27..24]: ingress::hdr.ipv4.ihl if ingress::hdr.ipv4.$valid
        # - bit[23..16]: ingress::hdr.ipv4.diffserv if ingress::hdr.ipv4.$valid
        # - bit[15..0]: ingress::hdr.ipv4.total_len if ingress::hdr.ipv4.$valid
    TW7: B6(1)
        # - bit[31..16]: ingress::hdr.ipv4.identification if ingress::hdr.ipv4.$valid
        # - bit[15..13]: ingress::hdr.ipv4.flags if ingress::hdr.ipv4.$valid
        # - bit[12..0]: ingress::hdr.ipv4.frag_offset if ingress::hdr.ipv4.$valid
    TW6: B6(1)
        # - bit[31..24]: ingress::hdr.ipv4.ttl if ingress::hdr.ipv4.$valid
        # - bit[23..16]: ingress::hdr.ipv4.protocol if ingress::hdr.ipv4.$valid
        # - bit[15..0]: ingress::hdr.ipv4.hdr_checksum if ingress::hdr.ipv4.$valid
    W0: B6(1)  # ingress::hdr.ipv4.src_addr if ingress::hdr.ipv4.$valid
    TW8: B6(1)  # ingress::hdr.ipv4.dst_addr if ingress::hdr.ipv4.$valid
    TH9: B6(3)  # ingress::hdr.tcp.src_port if ingress::hdr.tcp.$valid
    TH8: B6(3)  # ingress::hdr.tcp.dst_port if ingress::hdr.tcp.$valid
    TW10: B6(3)  # ingress::hdr.tcp.seq_no if ingress::hdr.tcp.$valid
    TW9: B6(3)  # ingress::hdr.tcp.ack_no if ingress::hdr.tcp.$valid
    TW5: B6(3)
        # - bit[31..28]: ingress::hdr.tcp.data_offset if ingress::hdr.tcp.$valid
        # - bit[27..24]: ingress::hdr.tcp.res if ingress::hdr.tcp.$valid
        # - bit[23..16]: ingress::hdr.tcp.flags if ingress::hdr.tcp.$valid
        # - bit[15..0]: ingress::hdr.tcp.window if ingress::hdr.tcp.$valid
    TH7: B6(3)  # ingress::hdr.tcp.checksum if ingress::hdr.tcp.$valid
    TH6: B6(3)  # ingress::hdr.tcp.urgent_ptr if ingress::hdr.tcp.$valid
    TH7: B6(2)  # ingress::hdr.udp.src_port if ingress::hdr.udp.$valid
    TH6: B6(2)  # ingress::hdr.udp.dst_port if ingress::hdr.udp.$valid
    TW5: B6(2)
        # - bit[31..16]: ingress::hdr.udp.hdr_length if ingress::hdr.udp.$valid
        # - bit[15..0]: ingress::hdr.udp.checksum if ingress::hdr.udp.$valid
  egress_unicast_port: H0(0..8)  # bit[8..0]: ingress::ig_intr_md_for_tm.ucast_egress_port
  drop_ctl: B4(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.drop_ctl
  learning:
    select: B1(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.digest_type
    5:
      - B1(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.digest_type
      - W0  # ingress::hdr.ipv4.src_addr
    context_json:
      5:
        - [ hdr.ipv4.src_addr, 1, 32, 7, 0]
      name: [ WaterfallIngressDeparser.digest ]
  mirror:
    select: B3(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.mirror_type
    0:
      - H1(0..9)  # bit[9..0]: ingress::$tmp2
  resubmit:
    select: B2(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.resubmit_type
    3:
      - B5  # ingress::ig_md.resubmit_md.type
      - W3  # ingress::ig_md.resubmit_md.remain
      - B0  # ingress::$tmp3.16-23
      - B0  # ingress::$tmp3.8-15
      - B0  # ingress::$tmp3.0-7
parser egress:
  start: $entry_point
  init_zero: [ W21, W22, W16, W18, W17, W19, B17, B16 ]
  bitwise_or: [ B16, B17 ]
  hdr_len_adj: 27
  meta_opt: 8191
  states:
    $entry_point:
      *:
        counter:
          imm: 24
        0..1: H16  # bit[7..15] -> H16 bit[8..0]: egress::eg_intr_md.egress_port
        27: TB14  # egress::hdr.ethernet.dst_addr[47:40].40-47
        28: TB13  # egress::hdr.ethernet.dst_addr[39:32].32-39
        B17: 1  # value 1 -> B17 bit[0]: egress::hdr.ethernet.$valid
        intr_md: 9
        shift: 29
        buf_req: 29
        next: start.$oob_stall_0
    start.$oob_stall_0:
      *:
        load: { half : 10..11 }
        buf_req: 12
        next: start.$split_0
    start.$split_0:
      match: [ half ]
      0x0800:
        0..3: TW15  # egress::hdr.ethernet.dst_addr[31:0].0-31
        4..5: TH23  # egress::hdr.ethernet.src_addr[47:32].32-47
        6..9: TW14  # egress::hdr.ethernet.src_addr[31:0].0-31
        10..11: TH22  # egress::hdr.ethernet.ether_type
        load: { byte1 : 21 }
        shift: 12
        buf_req: 22
        next: parse_ipv4
      0x****:
        0..3: TW15  # egress::hdr.ethernet.dst_addr[31:0].0-31
        4..5: TH23  # egress::hdr.ethernet.src_addr[47:32].32-47
        6..9: TW14  # egress::hdr.ethernet.src_addr[31:0].0-31
        10..11: TH22  # egress::hdr.ethernet.ether_type
        shift: 12
        buf_req: 12
        next: min_parse_depth_reject_initial
    parse_ipv4:
      match: [ byte1 ]
      0x06:
        counter: dec 20
        0..3: TW0
            # - bit[0..3] -> TW0 bit[31..28]: egress::hdr.ipv4.version
            # - bit[4..7] -> TW0 bit[27..24]: egress::hdr.ipv4.ihl
            # - bit[8..15] -> TW0 bit[23..16]: egress::hdr.ipv4.diffserv
            # - bit[16..31] -> TW0 bit[15..0]: egress::hdr.ipv4.total_len
        4..7: TW2
            # - bit[32..47] -> TW2 bit[31..16]: egress::hdr.ipv4.identification
            # - bit[48..50] -> TW2 bit[15..13]: egress::hdr.ipv4.flags
            # - bit[51..63] -> TW2 bit[12..0]: egress::hdr.ipv4.frag_offset
        8..11: TW1
            # - bit[64..71] -> TW1 bit[31..24]: egress::hdr.ipv4.ttl
            # - bit[72..79] -> TW1 bit[23..16]: egress::hdr.ipv4.protocol
            # - bit[80..95] -> TW1 bit[15..0]: egress::hdr.ipv4.hdr_checksum
        12..15: W20  # egress::hdr.ipv4.src_addr
        16..17: TH19  # egress::hdr.ipv4.dst_addr[31:16].16-31
        18..19: TH18  # egress::hdr.ipv4.dst_addr[15:0].0-15
        B17: 2  # value 1 -> B17 bit[1]: egress::hdr.ipv4.$valid
        load: { half : 2..3 }
        shift: 20
        buf_req: 20
        next: parse_tcp
      0x11:
        counter: dec 20
        0..3: TW0
            # - bit[0..3] -> TW0 bit[31..28]: egress::hdr.ipv4.version
            # - bit[4..7] -> TW0 bit[27..24]: egress::hdr.ipv4.ihl
            # - bit[8..15] -> TW0 bit[23..16]: egress::hdr.ipv4.diffserv
            # - bit[16..31] -> TW0 bit[15..0]: egress::hdr.ipv4.total_len
        4..7: TW2
            # - bit[32..47] -> TW2 bit[31..16]: egress::hdr.ipv4.identification
            # - bit[48..50] -> TW2 bit[15..13]: egress::hdr.ipv4.flags
            # - bit[51..63] -> TW2 bit[12..0]: egress::hdr.ipv4.frag_offset
        8..11: TW1
            # - bit[64..71] -> TW1 bit[31..24]: egress::hdr.ipv4.ttl
            # - bit[72..79] -> TW1 bit[23..16]: egress::hdr.ipv4.protocol
            # - bit[80..95] -> TW1 bit[15..0]: egress::hdr.ipv4.hdr_checksum
        12..15: W20  # egress::hdr.ipv4.src_addr
        16..17: TH19  # egress::hdr.ipv4.dst_addr[31:16].16-31
        18..19: TH18  # egress::hdr.ipv4.dst_addr[15:0].0-15
        B17: 2  # value 1 -> B17 bit[1]: egress::hdr.ipv4.$valid
        load: { half : 22..23 }
        shift: 20
        buf_req: 24
        next: parse_udp
      0x**:
        counter: dec 20
        0..3: TW0
            # - bit[0..3] -> TW0 bit[31..28]: egress::hdr.ipv4.version
            # - bit[4..7] -> TW0 bit[27..24]: egress::hdr.ipv4.ihl
            # - bit[8..15] -> TW0 bit[23..16]: egress::hdr.ipv4.diffserv
            # - bit[16..31] -> TW0 bit[15..0]: egress::hdr.ipv4.total_len
        4..7: TW2
            # - bit[32..47] -> TW2 bit[31..16]: egress::hdr.ipv4.identification
            # - bit[48..50] -> TW2 bit[15..13]: egress::hdr.ipv4.flags
            # - bit[51..63] -> TW2 bit[12..0]: egress::hdr.ipv4.frag_offset
        8..11: TW1
            # - bit[64..71] -> TW1 bit[31..24]: egress::hdr.ipv4.ttl
            # - bit[72..79] -> TW1 bit[23..16]: egress::hdr.ipv4.protocol
            # - bit[80..95] -> TW1 bit[15..0]: egress::hdr.ipv4.hdr_checksum
        12..15: W20  # egress::hdr.ipv4.src_addr
        16..17: TH19  # egress::hdr.ipv4.dst_addr[31:16].16-31
        18..19: TH18  # egress::hdr.ipv4.dst_addr[15:0].0-15
        B17: 2  # value 1 -> B17 bit[1]: egress::hdr.ipv4.$valid
        shift: 20
        buf_req: 20
        next: min_parse_depth_accept_initial
    parse_tcp:
      *:
        counter: dec 20
        0..1: TH1  # egress::hdr.tcp.src_port
        2..3: TH0  # egress::hdr.tcp.dst_port
        4..7: TW13  # egress::hdr.tcp.seq_no
        8..11: TW12  # egress::hdr.tcp.ack_no
        12: TB2
            # - bit[96..99] -> TB2 bit[7..4]: egress::hdr.tcp.data_offset
            # - bit[100..103] -> TB2 bit[3..0]: egress::hdr.tcp.res
        13: TB3  # egress::hdr.tcp.flags
        14: TB1  # egress::hdr.tcp.window[15:8].8-15
        15: TB0  # egress::hdr.tcp.window[7:0].0-7
        16..19: TW3
            # - bit[128..143] -> TW3 bit[31..16]: egress::hdr.tcp.checksum
            # - bit[144..159] -> TW3 bit[15..0]: egress::hdr.tcp.urgent_ptr
        shift: 20
        buf_req: 20
        next: parse_tcp.$split_0
    parse_tcp.$split_0:
      match: [ half ]
      0x****:
        B17: 4  # value 1 -> B17 bit[2]: egress::hdr.tcp.$valid
        buf_req: 0
        next: end
    parse_udp:
      match: [ half ]
      0x****:
        counter: dec 8
        0..1: TH1  # egress::hdr.udp.src_port
        2..3: TH0  # egress::hdr.udp.dst_port
        4..7: TW3
            # - bit[32..47] -> TW3 bit[31..16]: egress::hdr.udp.hdr_length
            # - bit[48..63] -> TW3 bit[15..0]: egress::hdr.udp.checksum
        B17: 8  # value 1 -> B17 bit[3]: egress::hdr.udp.$valid
        shift: 8
        buf_req: 8
        next: end
    min_parse_depth_accept_initial:
      match: [ ctr_neg, ctr_zero ]
      0x0:
        counter: dec 11
        0: TB0  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[87:80].80-87
        1: TB12  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[79:72].72-79
        2: TB3  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[71:64].64-71
        3..4: TH1  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[63:48].48-63
        5..6: TH0  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[47:32].32-47
        7..10: TW3  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[31:0].0-31
        B16: 4  # value 4 -> B16 bit[2..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 11
        buf_req: 11
        next: min_parse_depth_accept_loop.$split_0
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_accept_loop.$split_0:
      match: [ ctr_neg, ctr_zero ]
      0x0:
        counter: dec 11
        0: TB1  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[87:80].80-87
        1..2: TH20  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[79:64].64-79
        3..4: TH5  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[63:48].48-63
        5..6: TH4  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[47:32].32-47
        7..8: TH3  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[31:16].16-31
        B16: 2  # value 2 -> B16 bit[2..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 9
        buf_req: 9
        next: min_parse_depth_accept_loop.$it1.$split_0
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_accept_loop.$it1.$split_0:
      match: [ ctr_neg, ctr_zero ]
      0x0:
        0..1: TH2  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[15:0].0-15
        shift: 2
        buf_req: 2
        next: min_parse_depth_accept_loop.$it2
      0b**:
        0..1: TH2  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[15:0].0-15
        shift: 2
        buf_req: 2
        next: end
    min_parse_depth_accept_loop.$it2:
      *:
        counter: dec 11
        0: TB2  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[87:80].80-87
        1..2: TH21  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[79:64].64-79
        3..6: TW13  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[63:32].32-63
        7..10: TW12  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[31:0].0-31
        B16: 1  # value 1 -> B16 bit[2..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 11
        buf_req: 11
        next: end
    min_parse_depth_reject_initial:
      match: [ ctr_neg, ctr_zero ]
      0x0:
        buf_req: 0
        next: min_parse_depth_reject_loop
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_reject_loop:
      *:
        counter: dec 11
        buf_req: 0
        next: min_parse_depth_reject_loop.$split_0
    min_parse_depth_reject_loop.$split_0:
      match: [ ctr_neg, ctr_zero ]
      0x0:
        buf_req: 0
        next: min_parse_depth_reject_loop
      0b**:
        buf_req: 0
        next: end
deparser egress:
  dictionary:
    TB14: B17(0)  # egress::hdr.ethernet.dst_addr.40-47 if egress::hdr.ethernet.$valid
    TB13: B17(0)  # egress::hdr.ethernet.dst_addr.32-39 if egress::hdr.ethernet.$valid
    TW15: B17(0)  # egress::hdr.ethernet.dst_addr.0-31 if egress::hdr.ethernet.$valid
    TH23: B17(0)  # egress::hdr.ethernet.src_addr.32-47 if egress::hdr.ethernet.$valid
    TW14: B17(0)  # egress::hdr.ethernet.src_addr.0-31 if egress::hdr.ethernet.$valid
    TH22: B17(0)  # egress::hdr.ethernet.ether_type if egress::hdr.ethernet.$valid
    TW0: B17(1)
        # - bit[31..28]: egress::hdr.ipv4.version if egress::hdr.ipv4.$valid
        # - bit[27..24]: egress::hdr.ipv4.ihl if egress::hdr.ipv4.$valid
        # - bit[23..16]: egress::hdr.ipv4.diffserv if egress::hdr.ipv4.$valid
        # - bit[15..0]: egress::hdr.ipv4.total_len if egress::hdr.ipv4.$valid
    TW2: B17(1)
        # - bit[31..16]: egress::hdr.ipv4.identification if egress::hdr.ipv4.$valid
        # - bit[15..13]: egress::hdr.ipv4.flags if egress::hdr.ipv4.$valid
        # - bit[12..0]: egress::hdr.ipv4.frag_offset if egress::hdr.ipv4.$valid
    TW1: B17(1)
        # - bit[31..24]: egress::hdr.ipv4.ttl if egress::hdr.ipv4.$valid
        # - bit[23..16]: egress::hdr.ipv4.protocol if egress::hdr.ipv4.$valid
        # - bit[15..0]: egress::hdr.ipv4.hdr_checksum if egress::hdr.ipv4.$valid
    W20: B17(1)  # egress::hdr.ipv4.src_addr if egress::hdr.ipv4.$valid
    TH19: B17(1)  # egress::hdr.ipv4.dst_addr.16-31 if egress::hdr.ipv4.$valid
    TH18: B17(1)  # egress::hdr.ipv4.dst_addr.0-15 if egress::hdr.ipv4.$valid
    TH1: B17(2)  # egress::hdr.tcp.src_port if egress::hdr.tcp.$valid
    TH0: B17(2)  # egress::hdr.tcp.dst_port if egress::hdr.tcp.$valid
    TW13: B17(2)  # egress::hdr.tcp.seq_no if egress::hdr.tcp.$valid
    TW12: B17(2)  # egress::hdr.tcp.ack_no if egress::hdr.tcp.$valid
    TB2: B17(2)
        # - bit[7..4]: egress::hdr.tcp.data_offset if egress::hdr.tcp.$valid
        # - bit[3..0]: egress::hdr.tcp.res if egress::hdr.tcp.$valid
    TB3: B17(2)  # egress::hdr.tcp.flags if egress::hdr.tcp.$valid
    TB1: B17(2)  # egress::hdr.tcp.window.8-15 if egress::hdr.tcp.$valid
    TB0: B17(2)  # egress::hdr.tcp.window.0-7 if egress::hdr.tcp.$valid
    TW3: B17(2)
        # - bit[31..16]: egress::hdr.tcp.checksum if egress::hdr.tcp.$valid
        # - bit[15..0]: egress::hdr.tcp.urgent_ptr if egress::hdr.tcp.$valid
    TH1: B17(3)  # egress::hdr.udp.src_port if egress::hdr.udp.$valid
    TH0: B17(3)  # egress::hdr.udp.dst_port if egress::hdr.udp.$valid
    TW3: B17(3)
        # - bit[31..16]: egress::hdr.udp.hdr_length if egress::hdr.udp.$valid
        # - bit[15..0]: egress::hdr.udp.checksum if egress::hdr.udp.$valid
    TB0: B16(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TB12: B16(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.72-79 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TB3: B16(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.64-71 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TH1: B16(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.48-63 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TH0: B16(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.32-47 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TW3: B16(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.0-31 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TB1: B16(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TH20: B16(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TH5: B16(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.48-63 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TH4: B16(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.32-47 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TH3: B16(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.16-31 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TH2: B16(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.0-15 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TB2: B16(0)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH21: B16(0)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TW13: B16(0)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.32-63 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TW12: B16(0)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.0-31 if egress::hdr.min_parse_depth_padding_0[2].$valid
  egress_unicast_port: H16(0..8)  # bit[8..0]: egress::eg_intr_md.egress_port
stage 0 ingress:
  phase0_match WaterfallIngressParser.$PORT_METADATA:
    p4:
      name: WaterfallIngressParser.$PORT_METADATA
      size: 288
      preferred_match_type: exact
      match_type: exact
    size: 288
    p4_param_order:
      ig_intr_md.ingress_port: { type: exact, size: 9 }
    format: {f1: 32..63, f2: 0..31}
    constant_value: 0
    actions:
      set_port_metadata:
      - handle: 0x20000000
      - p4_param_order: { f1: 32, f2: 32 } 
  exact_match forward_0 0:
    p4: { name: WaterfallIngress.forward, size: 512 }
    p4_param_order: 
      ig_intr_md.ingress_port: { type: exact, size: 9, full_size: 9 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    input_xbar:
      exact group 0: { 0: ig_intr_md.ingress_port }
      hash 0:
        0..7: ig_intr_md.ingress_port(0..7)
        8: ig_intr_md.ingress_port(8)
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..1, immediate(0): 10..18, version(0): 112..115, action(1): 2..3, immediate(1): 19..27, version(1): 116..119, action(2): 4..5, immediate(2): 28..36, version(2): 120..123, action(3): 6..7, immediate(3): 37..45, version(3): 124..127, action(4): 8..9, immediate(4): 46..54, version(4): 56..59 }
    match_group_map: [ [ 0, 1, 2, 3, 4 ] ]
    hit: [  swap1_hi_0 ]
    miss:  swap1_hi_0
    action_bus: { 32..33 : immediate(0..8) }
    instruction: forward_0(action, $DEFAULT)
    actions:
      WaterfallIngress.hit(0, 1):
      - p4_param_order: { dst_port: 9 }
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000001
      - next_table: 0
      - { dst_port_1: immediate(0..8), dst_port: dst_port_1 }
      - set ig_intr_md_for_tm.ucast_egress_port, dst_port
      - set B4(3..4), 0
      WaterfallIngress.drop(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000002
      - next_table: 0
      - {  }
      - set ig_intr_md_for_dprsr.drop_ctl, 1
      WaterfallIngress.no_action(2, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000003
      - next_table: 0
      - {  }
    default_action: WaterfallIngress.drop
stage 1 ingress:
  dependency: match
  exact_match swap1_hi_0 0:
    p4: { name: WaterfallIngress.swap1_hi, size: 8 }
    p4_param_order: 
      ig_intr_md.resubmit_flag: { type: exact, size: 1, full_size: 1 }
      ig_md.found_hi: { type: exact, size: 1, full_size: 1 }
      ig_md.found_lo: { type: exact, size: 1, full_size: 1 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    hash_dist:
      0: { hash: 2, mask: 0xffff, shift: 4 }
    input_xbar:
      exact group 0: { 3: ig_md.found_hi, 4: ig_md.found_lo, 15: ig_intr_md.resubmit_flag }
      hash 0:
        0: ig_md.found_hi
        1: ig_md.found_lo
        2: ig_intr_md.resubmit_flag
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 1: { 0: hdr.ipv4.src_addr }
      hash 2:
        0..15: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 32, { 0: hdr.ipv4.src_addr }, { })), 0..15)
      hash group 2:
        table: [2]
        seed: 0xdf1c
    format: { action(0): 0..1, version(0): 112..115, meter_addr(0): 4..19, meter_pfe(0): 20..20, meter_type(0): 21..23, action(1): 2..3, version(1): 116..119, meter_addr(1): 24..39, meter_pfe(1): 40..40, meter_type(1): 41..43 }
    match_group_map: [ [ 0, 1 ] ]
    hit: [  swap1_lo_0 ]
    miss:  swap1_lo_0
    action_bus: { 0 : swap1_hi_0$salu.WaterfallIngress.table_1_hi(0..7), 96..99 : swap1_hi_0$salu.WaterfallIngress.table_1_hi(0..31) }
    stateful: swap1_hi_0$salu.WaterfallIngress.table_1_hi(hash_dist 0, meter_pfe, meter_type)
    instruction: swap1_hi_0(action, $DEFAULT)
    actions:
      WaterfallIngress.do_swap1_hi(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000004
      - next_table: 0
      - set W4(0..15), swap1_hi_0$salu.WaterfallIngress.table_1_hi
      - swap1_hi_0$salu.WaterfallIngress.table_1_hi(table_1_hi_swap_0, $hash_dist)
      WaterfallIngress.lookup1_hi(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000005
      - next_table: 0
      - set ig_md.remain1_hi, hdr.ipv4.src_addr(16..31)
      - set B4(3..3), swap1_hi_0$salu.WaterfallIngress.table_1_hi
      - swap1_hi_0$salu.WaterfallIngress.table_1_hi(table_1_hi_lookup_0, $hash_dist)
      WaterfallIngress.no_action(2, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000006
      - next_table: 0
    default_action: WaterfallIngress.no_action
  stateful swap1_hi_0$salu.WaterfallIngress.table_1_hi:
    p4: { name: WaterfallIngress.table_1_hi, size: 65535 }
    row: [ 3, 1 ]
    logical_bus: [ S, O ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    home_row: 3
    input_xbar:
      exact group 0: { 80: hdr.ipv4.src_addr(16..31), 112: ig_md.resubmit_md.remain(16..31) }
      hash 1:
        0..15: ig_md.resubmit_md.remain(16..31)
        16..31: hdr.ipv4.src_addr(16..31)
      hash group 1:
        table: [1]
        seed: 0x0
    hash_bytemask: 15
    format: { lo: 16 }
    actions:
      table_1_hi_swap_0:
      - alu_a lo, phv_lo
      - output mem_lo
      table_1_hi_lookup_0:
      - equ lo, phv_hi, -lo
      - alu_a cmplo, hi, 1
      - output cmplo, alu_hi
stage 2 ingress:
  dependency: match
  exact_match swap1_lo_0 0:
    p4: { name: WaterfallIngress.swap1_lo, size: 8 }
    p4_param_order: 
      ig_intr_md.resubmit_flag: { type: exact, size: 1, full_size: 1 }
      ig_md.found_hi: { type: exact, size: 1, full_size: 1 }
      ig_md.found_lo: { type: exact, size: 1, full_size: 1 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    hash_dist:
      0: { hash: 2, mask: 0xffff, shift: 4 }
    input_xbar:
      exact group 0: { 3: ig_md.found_hi, 4: ig_md.found_lo, 15: ig_intr_md.resubmit_flag }
      hash 0:
        0: ig_md.found_hi
        1: ig_md.found_lo
        2: ig_intr_md.resubmit_flag
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 1: { 0: hdr.ipv4.src_addr }
      hash 2:
        0..15: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 32, { 0: hdr.ipv4.src_addr }, { })), 0..15)
      hash group 2:
        table: [2]
        seed: 0xdf1c
    format: { action(0): 0..1, version(0): 112..115, meter_addr(0): 4..19, meter_pfe(0): 20..20, meter_type(0): 21..23, action(1): 2..3, version(1): 116..119, meter_addr(1): 24..39, meter_pfe(1): 40..40, meter_type(1): 41..43 }
    match_group_map: [ [ 0, 1 ] ]
    hit: [  swap2_hi_0 ]
    miss:  swap2_hi_0
    action_bus: { 0 : swap1_lo_0$salu.WaterfallIngress.table_1_lo(0..7), 96..99 : swap1_lo_0$salu.WaterfallIngress.table_1_lo(0..31) }
    stateful: swap1_lo_0$salu.WaterfallIngress.table_1_lo(hash_dist 0, meter_pfe, meter_type)
    instruction: swap1_lo_0(action, $DEFAULT)
    actions:
      WaterfallIngress.do_swap1_lo(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000007
      - next_table: 0
      - set W1(0..15), swap1_lo_0$salu.WaterfallIngress.table_1_lo
      - swap1_lo_0$salu.WaterfallIngress.table_1_lo(table_1_lo_swap_0, $hash_dist)
      WaterfallIngress.lookup1_lo(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000008
      - next_table: 0
      - set ig_md.remain1_lo, hdr.ipv4.src_addr(0..15)
      - set B4(4..4), swap1_lo_0$salu.WaterfallIngress.table_1_lo
      - swap1_lo_0$salu.WaterfallIngress.table_1_lo(table_1_lo_lookup_0, $hash_dist)
      WaterfallIngress.no_action(2, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000009
      - next_table: 0
    default_action: WaterfallIngress.no_action
  stateful swap1_lo_0$salu.WaterfallIngress.table_1_lo:
    p4: { name: WaterfallIngress.table_1_lo, size: 65535 }
    row: [ 3, 1 ]
    logical_bus: [ S, O ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    home_row: 3
    input_xbar:
      exact group 0: { 64: hdr.ipv4.src_addr(0..15), 96: ig_md.resubmit_md.remain(0..15) }
      hash 1:
        0..15: ig_md.resubmit_md.remain(0..15)
        16..31: hdr.ipv4.src_addr(0..15)
      hash group 1:
        table: [1]
        seed: 0x0
    hash_bytemask: 15
    format: { lo: 16 }
    actions:
      table_1_lo_swap_0:
      - alu_a lo, phv_lo
      - output mem_lo
      table_1_lo_lookup_0:
      - equ lo, phv_hi, -lo
      - alu_a cmplo, hi, 1
      - output cmplo, alu_hi
stage 3 ingress:
  dependency: match
  exact_match swap2_hi_0 0:
    p4: { name: WaterfallIngress.swap2_hi, size: 8 }
    p4_param_order: 
      ig_intr_md.resubmit_flag: { type: exact, size: 1, full_size: 1 }
      ig_md.found_hi: { type: exact, size: 1, full_size: 1 }
      ig_md.found_lo: { type: exact, size: 1, full_size: 1 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    hash_dist:
      0: { hash: 1, mask: 0xffff, shift: 4 }
    input_xbar:
      exact group 0: { 3: ig_md.found_hi, 4: ig_md.found_lo, 15: ig_intr_md.resubmit_flag }
      hash 0:
        0: ig_md.found_hi
        1: ig_md.found_lo
        2: ig_intr_md.resubmit_flag
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 64: ig_md.remain1_hi, 96: ig_md.remain1_lo }
      hash 1:
        0..15: slice(stripe(crc_rev(0x82608edb, 0xfffffff0, 0xffffffff, 32, { 0: ig_md.remain1_lo, 16: ig_md.remain1_hi }, { })), 0..15)
      hash group 1:
        table: [1]
        seed: 0x2d00
    format: { action(0): 0..1, version(0): 112..115, meter_addr(0): 4..19, meter_pfe(0): 20..20, meter_type(0): 21..23, action(1): 2..3, version(1): 116..119, meter_addr(1): 24..39, meter_pfe(1): 40..40, meter_type(1): 41..43 }
    match_group_map: [ [ 0, 1 ] ]
    hit: [  swap2_lo_0 ]
    miss:  swap2_lo_0
    action_bus: { 0 : swap2_hi_0$salu.WaterfallIngress.table_2_hi(0..7), 96..99 : swap2_hi_0$salu.WaterfallIngress.table_2_hi(0..31) }
    stateful: swap2_hi_0$salu.WaterfallIngress.table_2_hi(hash_dist 0, meter_pfe, meter_type)
    instruction: swap2_hi_0(action, $DEFAULT)
    actions:
      WaterfallIngress.do_swap2_hi(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000000a
      - next_table: 0
      - set W5(0..15), swap2_hi_0$salu.WaterfallIngress.table_2_hi
      - swap2_hi_0$salu.WaterfallIngress.table_2_hi(table_2_hi_swap_0, $hash_dist)
      WaterfallIngress.lookup2_hi(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000000b
      - next_table: 0
      - set ig_md.remain2_hi, hdr.ipv4.src_addr(16..31)
      - set B4(3..3), swap2_hi_0$salu.WaterfallIngress.table_2_hi
      - swap2_hi_0$salu.WaterfallIngress.table_2_hi(table_2_hi_lookup_0, $hash_dist)
      WaterfallIngress.no_action(2, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000000c
      - next_table: 0
    default_action: WaterfallIngress.no_action
  stateful swap2_hi_0$salu.WaterfallIngress.table_2_hi:
    p4: { name: WaterfallIngress.table_2_hi, size: 65535 }
    row: [ 11, 9 ]
    logical_bus: [ S, O ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    home_row: 11
    input_xbar:
      exact group 0: { 64: ig_md.remain1_hi, 80: hdr.ipv4.src_addr(16..31) }
    data_bytemask: 15
    format: { lo: 16 }
    actions:
      table_2_hi_swap_0:
      - alu_a lo, phv_lo
      - output mem_lo
      table_2_hi_lookup_0:
      - equ lo, phv_hi, -lo
      - alu_a cmplo, hi, 1
      - output cmplo, alu_hi
stage 4 ingress:
  dependency: match
  exact_match swap2_lo_0 0:
    p4: { name: WaterfallIngress.swap2_lo, size: 8 }
    p4_param_order: 
      ig_intr_md.resubmit_flag: { type: exact, size: 1, full_size: 1 }
      ig_md.found_hi: { type: exact, size: 1, full_size: 1 }
      ig_md.found_lo: { type: exact, size: 1, full_size: 1 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    hash_dist:
      0: { hash: 2, mask: 0xffff, shift: 4 }
    input_xbar:
      exact group 0: { 3: ig_md.found_hi, 4: ig_md.found_lo, 15: ig_intr_md.resubmit_flag }
      hash 0:
        0: ig_md.found_hi
        1: ig_md.found_lo
        2: ig_intr_md.resubmit_flag
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 1: { 0: ig_md.remain1_lo, 32: ig_md.remain1_hi }
      hash 2:
        0..15: slice(stripe(crc_rev(0x82608edb, 0xfffffff0, 0xffffffff, 32, { 0: ig_md.remain1_lo, 16: ig_md.remain1_hi }, { })), 0..15)
      hash group 2:
        table: [2]
        seed: 0x2d00
    format: { action(0): 0..1, version(0): 112..115, meter_addr(0): 4..19, meter_pfe(0): 20..20, meter_type(0): 21..23, action(1): 2..3, version(1): 116..119, meter_addr(1): 24..39, meter_pfe(1): 40..40, meter_type(1): 41..43 }
    match_group_map: [ [ 0, 1 ] ]
    hit: [  swap3_hi_0 ]
    miss:  swap3_hi_0
    action_bus: { 0 : swap2_lo_0$salu.WaterfallIngress.table_2_lo(0..7), 96..99 : swap2_lo_0$salu.WaterfallIngress.table_2_lo(0..31) }
    stateful: swap2_lo_0$salu.WaterfallIngress.table_2_lo(hash_dist 0, meter_pfe, meter_type)
    instruction: swap2_lo_0(action, $DEFAULT)
    actions:
      WaterfallIngress.do_swap2_lo(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000000d
      - next_table: 0
      - set W2(0..15), swap2_lo_0$salu.WaterfallIngress.table_2_lo
      - swap2_lo_0$salu.WaterfallIngress.table_2_lo(table_2_lo_swap_0, $hash_dist)
      WaterfallIngress.lookup2_lo(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000000e
      - next_table: 0
      - set ig_md.remain2_lo, hdr.ipv4.src_addr(0..15)
      - set B4(4..4), swap2_lo_0$salu.WaterfallIngress.table_2_lo
      - swap2_lo_0$salu.WaterfallIngress.table_2_lo(table_2_lo_lookup_0, $hash_dist)
      WaterfallIngress.no_action(2, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000000f
      - next_table: 0
    default_action: WaterfallIngress.no_action
  stateful swap2_lo_0$salu.WaterfallIngress.table_2_lo:
    p4: { name: WaterfallIngress.table_2_lo, size: 65535 }
    row: [ 15, 13 ]
    logical_bus: [ S, O ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    home_row: 15
    input_xbar:
      exact group 0: { 64: hdr.ipv4.src_addr(0..15), 96: ig_md.remain1_lo }
      hash 1:
        0..15: ig_md.remain1_lo
        16..31: hdr.ipv4.src_addr(0..15)
      hash group 1:
        table: [1]
        seed: 0x0
    hash_bytemask: 15
    format: { lo: 16 }
    actions:
      table_2_lo_swap_0:
      - alu_a lo, phv_lo
      - output mem_lo
      table_2_lo_lookup_0:
      - equ lo, phv_hi, -lo
      - alu_a cmplo, hi, 1
      - output cmplo, alu_hi
stage 5 ingress:
  dependency: match
  exact_match swap3_hi_0 0:
    p4: { name: WaterfallIngress.swap3_hi, size: 8 }
    p4_param_order: 
      ig_intr_md.resubmit_flag: { type: exact, size: 1, full_size: 1 }
      ig_md.found_hi: { type: exact, size: 1, full_size: 1 }
      ig_md.found_lo: { type: exact, size: 1, full_size: 1 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    hash_dist:
      0: { hash: 1, mask: 0xffff, shift: 4 }
    input_xbar:
      exact group 0: { 3: ig_md.found_hi, 4: ig_md.found_lo, 15: ig_intr_md.resubmit_flag }
      hash 0:
        0: ig_md.found_hi
        1: ig_md.found_lo
        2: ig_intr_md.resubmit_flag
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 64: ig_md.remain2_hi, 96: ig_md.remain2_lo }
      hash 1:
        0..15: slice(stripe(crc_rev(0x82608edb, 0xffffff00, 0xffffffff, 32, { 0: ig_md.remain2_lo, 16: ig_md.remain2_hi }, { })), 0..15)
      hash group 1:
        table: [1]
        seed: 0x3091
    format: { action(0): 0..1, version(0): 112..115, meter_addr(0): 4..19, meter_pfe(0): 20..20, meter_type(0): 21..23, action(1): 2..3, version(1): 116..119, meter_addr(1): 24..39, meter_pfe(1): 40..40, meter_type(1): 41..43 }
    match_group_map: [ [ 0, 1 ] ]
    hit: [  swap3_lo_0 ]
    miss:  swap3_lo_0
    action_bus: { 0 : swap3_hi_0$salu.WaterfallIngress.table_3_hi(0..7), 96..99 : swap3_hi_0$salu.WaterfallIngress.table_3_hi(0..31) }
    stateful: swap3_hi_0$salu.WaterfallIngress.table_3_hi(hash_dist 0, meter_pfe, meter_type)
    instruction: swap3_hi_0(action, $DEFAULT)
    actions:
      WaterfallIngress.do_swap3_hi(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000010
      - next_table: 0
      - set W4(0..15), swap3_hi_0$salu.WaterfallIngress.table_3_hi
      - swap3_hi_0$salu.WaterfallIngress.table_3_hi(table_3_hi_swap_0, $hash_dist)
      WaterfallIngress.lookup3_hi(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000011
      - next_table: 0
      - set ig_md.remain3_hi, hdr.ipv4.src_addr(16..31)
      - set B4(3..3), swap3_hi_0$salu.WaterfallIngress.table_3_hi
      - swap3_hi_0$salu.WaterfallIngress.table_3_hi(table_3_hi_lookup_0, $hash_dist)
      WaterfallIngress.no_action(2, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000012
      - next_table: 0
    default_action: WaterfallIngress.no_action
  stateful swap3_hi_0$salu.WaterfallIngress.table_3_hi:
    p4: { name: WaterfallIngress.table_3_hi, size: 65535 }
    row: [ 15, 13 ]
    logical_bus: [ S, O ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    home_row: 15
    input_xbar:
      exact group 0: { 64: ig_md.remain2_hi, 80: hdr.ipv4.src_addr(16..31) }
    data_bytemask: 15
    format: { lo: 16 }
    actions:
      table_3_hi_swap_0:
      - alu_a lo, phv_lo
      - output mem_lo
      table_3_hi_lookup_0:
      - equ lo, phv_hi, -lo
      - alu_a cmplo, hi, 1
      - output cmplo, alu_hi
stage 6 ingress:
  dependency: match
  exact_match swap3_lo_0 0:
    p4: { name: WaterfallIngress.swap3_lo, size: 8 }
    p4_param_order: 
      ig_intr_md.resubmit_flag: { type: exact, size: 1, full_size: 1 }
      ig_md.found_hi: { type: exact, size: 1, full_size: 1 }
      ig_md.found_lo: { type: exact, size: 1, full_size: 1 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    hash_dist:
      0: { hash: 2, mask: 0xffff, shift: 4 }
    input_xbar:
      exact group 0: { 3: ig_md.found_hi, 4: ig_md.found_lo, 15: ig_intr_md.resubmit_flag }
      hash 0:
        0: ig_md.found_hi
        1: ig_md.found_lo
        2: ig_intr_md.resubmit_flag
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 1: { 0: ig_md.remain2_lo, 32: ig_md.remain2_hi }
      hash 2:
        0..15: slice(stripe(crc_rev(0x82608edb, 0xffffff00, 0xffffffff, 32, { 0: ig_md.remain2_lo, 16: ig_md.remain2_hi }, { })), 0..15)
      hash group 2:
        table: [2]
        seed: 0x3091
    format: { action(0): 0..1, version(0): 112..115, meter_addr(0): 4..19, meter_pfe(0): 20..20, meter_type(0): 21..23, action(1): 2..3, version(1): 116..119, meter_addr(1): 24..39, meter_pfe(1): 40..40, meter_type(1): 41..43 }
    match_group_map: [ [ 0, 1 ] ]
    hit: [  swap4_hi_0 ]
    miss:  swap4_hi_0
    action_bus: { 0 : swap3_lo_0$salu.WaterfallIngress.table_3_lo(0..7), 96..99 : swap3_lo_0$salu.WaterfallIngress.table_3_lo(0..31) }
    stateful: swap3_lo_0$salu.WaterfallIngress.table_3_lo(hash_dist 0, meter_pfe, meter_type)
    instruction: swap3_lo_0(action, $DEFAULT)
    actions:
      WaterfallIngress.do_swap3_lo(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000013
      - next_table: 0
      - set W1(0..15), swap3_lo_0$salu.WaterfallIngress.table_3_lo
      - swap3_lo_0$salu.WaterfallIngress.table_3_lo(table_3_lo_swap_0, $hash_dist)
      WaterfallIngress.lookup3_lo(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000014
      - next_table: 0
      - set ig_md.remain3_lo, hdr.ipv4.src_addr(0..15)
      - set B4(4..4), swap3_lo_0$salu.WaterfallIngress.table_3_lo
      - swap3_lo_0$salu.WaterfallIngress.table_3_lo(table_3_lo_lookup_0, $hash_dist)
      WaterfallIngress.no_action(2, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000015
      - next_table: 0
    default_action: WaterfallIngress.no_action
  stateful swap3_lo_0$salu.WaterfallIngress.table_3_lo:
    p4: { name: WaterfallIngress.table_3_lo, size: 65535 }
    row: [ 15, 13 ]
    logical_bus: [ S, O ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    home_row: 15
    input_xbar:
      exact group 0: { 64: hdr.ipv4.src_addr(0..15), 96: ig_md.remain2_lo }
      hash 1:
        0..15: ig_md.remain2_lo
        16..31: hdr.ipv4.src_addr(0..15)
      hash group 1:
        table: [1]
        seed: 0x0
    hash_bytemask: 15
    format: { lo: 16 }
    actions:
      table_3_lo_swap_0:
      - alu_a lo, phv_lo
      - output mem_lo
      table_3_lo_lookup_0:
      - equ lo, phv_hi, -lo
      - alu_a cmplo, hi, 1
      - output cmplo, alu_hi
stage 7 ingress:
  dependency: match
  exact_match swap4_hi_0 0:
    p4: { name: WaterfallIngress.swap4_hi, size: 8 }
    p4_param_order: 
      ig_intr_md.resubmit_flag: { type: exact, size: 1, full_size: 1 }
      ig_md.found_hi: { type: exact, size: 1, full_size: 1 }
      ig_md.found_lo: { type: exact, size: 1, full_size: 1 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    hash_dist:
      0: { hash: 1, mask: 0xffff, shift: 4 }
    input_xbar:
      exact group 0: { 3: ig_md.found_hi, 4: ig_md.found_lo, 15: ig_intr_md.resubmit_flag }
      hash 0:
        0: ig_md.found_hi
        1: ig_md.found_lo
        2: ig_intr_md.resubmit_flag
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 0: { 64: ig_md.remain3_hi, 96: ig_md.remain3_lo }
      hash 1:
        0..15: slice(stripe(crc_rev(0x82608edb, 0xfffff000, 0xffffffff, 32, { 0: ig_md.remain3_lo, 16: ig_md.remain3_hi }, { })), 0..15)
      hash group 1:
        table: [1]
        seed: 0xd12c
    format: { action(0): 0..1, version(0): 112..115, meter_addr(0): 4..19, meter_pfe(0): 20..20, meter_type(0): 21..23, action(1): 2..3, version(1): 116..119, meter_addr(1): 24..39, meter_pfe(1): 40..40, meter_type(1): 41..43 }
    match_group_map: [ [ 0, 1 ] ]
    hit: [  swap4_lo_0 ]
    miss:  swap4_lo_0
    action_bus: { 0 : swap4_hi_0$salu.WaterfallIngress.table_4_hi(0..7) }
    stateful: swap4_hi_0$salu.WaterfallIngress.table_4_hi(hash_dist 0, meter_pfe, meter_type)
    instruction: swap4_hi_0(action, $DEFAULT)
    actions:
      WaterfallIngress.do_swap4_hi(0, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000016
      - next_table: 0
      - swap4_hi_0$salu.WaterfallIngress.table_4_hi(table_4_hi_swap_0, $hash_dist)
      WaterfallIngress.lookup4_hi(1, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000017
      - next_table: 0
      - set B4(3..3), swap4_hi_0$salu.WaterfallIngress.table_4_hi
      - swap4_hi_0$salu.WaterfallIngress.table_4_hi(table_4_hi_lookup_0, $hash_dist)
      WaterfallIngress.no_action(2, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000018
      - next_table: 0
    default_action: WaterfallIngress.no_action
  stateful swap4_hi_0$salu.WaterfallIngress.table_4_hi:
    p4: { name: WaterfallIngress.table_4_hi, size: 65535 }
    row: [ 15, 13 ]
    logical_bus: [ S, O ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    home_row: 15
    input_xbar:
      exact group 0: { 64: ig_md.remain3_hi, 80: hdr.ipv4.src_addr(16..31) }
    data_bytemask: 15
    format: { lo: 16 }
    actions:
      table_4_hi_swap_0:
      - alu_a lo, phv_lo
      - output mem_lo
      table_4_hi_lookup_0:
      - equ lo, phv_hi, -lo
      - alu_a cmplo, hi, 1
      - output cmplo, alu_hi
stage 8 ingress:
  dependency: match
  exact_match swap4_lo_0 0:
    p4: { name: WaterfallIngress.swap4_lo, size: 8 }
    p4_param_order: 
      ig_intr_md.resubmit_flag: { type: exact, size: 1, full_size: 1 }
      ig_md.found_hi: { type: exact, size: 1, full_size: 1 }
      ig_md.found_lo: { type: exact, size: 1, full_size: 1 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    hash_dist:
      0: { hash: 2, mask: 0xffff, shift: 4 }
    input_xbar:
      exact group 0: { 3: ig_md.found_hi, 4: ig_md.found_lo, 15: ig_intr_md.resubmit_flag }
      hash 0:
        0: ig_md.found_hi
        1: ig_md.found_lo
        2: ig_intr_md.resubmit_flag
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 1: { 0: ig_md.remain3_lo, 32: ig_md.remain3_hi }
      hash 2:
        0..15: slice(stripe(crc_rev(0x82608edb, 0xfffff000, 0xffffffff, 32, { 0: ig_md.remain3_lo, 16: ig_md.remain3_hi }, { })), 0..15)
      hash group 2:
        table: [2]
        seed: 0xd12c
    format: { action(0): 0..1, version(0): 112..115, meter_addr(0): 4..19, meter_pfe(0): 20..20, meter_type(0): 21..23, action(1): 2..3, version(1): 116..119, meter_addr(1): 24..39, meter_pfe(1): 40..40, meter_type(1): 41..43 }
    match_group_map: [ [ 0, 1 ] ]
    hit: [  resub_0 ]
    miss:  resub_0
    action_bus: { 0 : swap4_lo_0$salu.WaterfallIngress.table_4_lo(0..7) }
    stateful: swap4_lo_0$salu.WaterfallIngress.table_4_lo(hash_dist 0, meter_pfe, meter_type)
    instruction: swap4_lo_0(action, $DEFAULT)
    actions:
      WaterfallIngress.do_swap4_lo(0, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000019
      - next_table: 0
      - swap4_lo_0$salu.WaterfallIngress.table_4_lo(table_4_lo_swap_0, $hash_dist)
      WaterfallIngress.lookup4_lo(1, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000001a
      - next_table: 0
      - set B4(4..4), swap4_lo_0$salu.WaterfallIngress.table_4_lo
      - swap4_lo_0$salu.WaterfallIngress.table_4_lo(table_4_lo_lookup_0, $hash_dist)
      WaterfallIngress.no_action(2, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000001b
      - next_table: 0
    default_action: WaterfallIngress.no_action
  stateful swap4_lo_0$salu.WaterfallIngress.table_4_lo:
    p4: { name: WaterfallIngress.table_4_lo, size: 65535 }
    row: [ 15, 13 ]
    logical_bus: [ S, O ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    home_row: 15
    input_xbar:
      exact group 0: { 64: hdr.ipv4.src_addr(0..15), 96: ig_md.remain3_lo }
      hash 1:
        0..15: ig_md.remain3_lo
        16..31: hdr.ipv4.src_addr(0..15)
      hash group 1:
        table: [1]
        seed: 0x0
    hash_bytemask: 15
    format: { lo: 16 }
    actions:
      table_4_lo_swap_0:
      - alu_a lo, phv_lo
      - output mem_lo
      table_4_lo_lookup_0:
      - equ lo, phv_hi, -lo
      - alu_a cmplo, hi, 1
      - output cmplo, alu_hi
stage 9 ingress:
  dependency: match
  exact_match resub_0 0:
    p4: { name: WaterfallIngress.resub, size: 8 }
    p4_param_order: 
      ig_md.found_hi: { type: exact, size: 1, full_size: 1 }
      ig_md.found_lo: { type: exact, size: 1, full_size: 1 }
      ig_intr_md.resubmit_flag: { type: exact, size: 1, full_size: 1 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    input_xbar:
      exact group 0: { 3: ig_md.found_hi, 4: ig_md.found_lo, 15: ig_intr_md.resubmit_flag }
      hash 0:
        0: ig_md.found_hi
        1: ig_md.found_lo
        2: ig_intr_md.resubmit_flag
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..0, version(0): 112..115, action(1): 1..1, version(1): 116..119, action(2): 2..2, version(2): 120..123, action(3): 3..3, version(3): 124..127, action(4): 4..4, version(4): 8..11 }
    match_group_map: [ [ 0, 1, 2, 3, 4 ] ]
    hit: [  END ]
    miss:  END
    instruction: resub_0(action, $DEFAULT)
    actions:
      WaterfallIngress.resubmit_hdr(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000001c
      - next_table: 0
      - set ig_intr_md_for_dprsr.resubmit_type, 3
      - set ig_md.resubmit_md.type, 3
      - set ig_md.resubmit_md.remain, hdr.ipv4.src_addr
      - set ig_intr_md_for_dprsr.digest_type, 5
      WaterfallIngress.no_action(1, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000001d
      - next_table: 0
    default_action: WaterfallIngress.no_action
stage 0 egress:
  hash_action tbl_fcmsketch_fcm_hash_d2 1:
    p4: { name: tbl_fcmsketch_fcm_hash_d2, hidden: true }
    row: 0
    result_bus: 1
    hash_dist:
      0: { hash: 1, mask: 0xffff, shift: 0 }
      1: { hash: 1, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 64: hdr.ipv4.src_addr }
      hash 1:
        0..15: slice(stripe(crc_rev(0x82608edb, 0xfffffff0, 0xffffffff, 32, { 0: hdr.ipv4.src_addr }, { })), 0..15)
      hash group 1:
        table: [1]
        seed: 0x2d00
      exact group 0: { 64: hdr.ipv4.src_addr }
      hash 1:
        16..31: slice(stripe(crc_rev(0x82608edb, 0xfffffff0, 0xffffffff, 32, { 0: hdr.ipv4.src_addr }, { })), 16..31)
      hash group 1:
        table: [1]
        seed: 0x9cf90000
    gateway:
      name: tbl_fcmsketch_fcm_hash_d2-gateway
      row: 0
      bus: 0
      unit: 1
      0x0:  tbl_fcmsketch_fcm_hash_d1
      miss:  tbl_fcmsketch_fcm_hash_d1
      condition: 
        expression: "true(always hit)"
        true:  tbl_fcmsketch_fcm_hash_d1
        false:  tbl_fcmsketch_fcm_hash_d1
    next: []
    action_bus: { 96..99 : hash_dist(0, 1) }
    instruction: tbl_fcmsketch_fcm_hash_d2($DEFAULT, $DEFAULT)
    actions:
      FcmEgress.fcmsketch.fcm_hash_d2(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000020
      - next_table: 0
      - set W22(0..31), hash_dist(0, 1, 0..31)
    default_action: FcmEgress.fcmsketch.fcm_hash_d2
  hash_action tbl_fcmsketch_fcm_hash_d1 2:
    p4: { name: tbl_fcmsketch_fcm_hash_d1, hidden: true }
    row: 0
    result_bus: 0
    hash_dist:
      2: { hash: 1, mask: 0xffff, shift: 0 }
      3: { hash: 2, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 64: hdr.ipv4.src_addr }
      hash 1:
        32..47: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 32, { 0: hdr.ipv4.src_addr }, { })), 0..15)
      hash group 1:
        table: [1]
        seed: 0xdf1c00000000
      exact group 1: { 0: hdr.ipv4.src_addr }
      hash 2:
        0..15: slice(stripe(crc_rev(0x82608edb, 0xffffffff, 0xffffffff, 32, { 0: hdr.ipv4.src_addr }, { })), 16..31)
      hash group 2:
        table: [2]
        seed: 0x2144
    gateway:
      name: tbl_fcmsketch_fcm_hash_d1-gateway
      row: 0
      bus: 0
      unit: 0
      0x0:  fcmsketch_tb_fcm_l1_to_l2_d2$precompute
      miss:  fcmsketch_tb_fcm_l1_to_l2_d2$precompute
      condition: 
        expression: "true(always hit)"
        true:  fcmsketch_tb_fcm_l1_to_l2_d2$precompute
        false:  fcmsketch_tb_fcm_l1_to_l2_d2$precompute
    next: []
    action_bus: { 100..103 : hash_dist(2, 3) }
    instruction: tbl_fcmsketch_fcm_hash_d1($DEFAULT, $DEFAULT)
    actions:
      FcmEgress.fcmsketch.fcm_hash_d1(0, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000001f
      - next_table: 0
      - set W21(0..31), hash_dist(2, 3, 0..31)
    default_action: FcmEgress.fcmsketch.fcm_hash_d1
  ternary_match fcmsketch_tb_fcm_l1_to_l2_d2$precompute 3:
    p4: { name: fcmsketch_tb_fcm_l1_to_l2_d2$precompute, hidden: true }
    hit: [  fcmsketch_tb_fcm_l1_to_l2_d1$precompute ]
    miss:  fcmsketch_tb_fcm_l1_to_l2_d1$precompute
    indirect: fcmsketch_tb_fcm_l1_to_l2_d2$precompute$tind
  ternary_indirect fcmsketch_tb_fcm_l1_to_l2_d2$precompute$tind:
    row: 0
    bus: 1
    format: { action: 0..0 }
    instruction: fcmsketch_tb_fcm_l1_to_l2_d2$precompute$tind(action, $DEFAULT)
    actions:
      $precompute(0, 3):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000026
      - next_table: 0
      - set $tmp45, 255
    default_action: $precompute
  ternary_match fcmsketch_tb_fcm_l1_to_l2_d1$precompute 4:
    p4: { name: fcmsketch_tb_fcm_l1_to_l2_d1$precompute, hidden: true }
    hit: [  tbl_count_pkt ]
    miss:  tbl_count_pkt
    indirect: fcmsketch_tb_fcm_l1_to_l2_d1$precompute$tind
  ternary_indirect fcmsketch_tb_fcm_l1_to_l2_d1$precompute$tind:
    row: 0
    bus: 0
    format: { action: 0..0 }
    instruction: fcmsketch_tb_fcm_l1_to_l2_d1$precompute$tind(action, $DEFAULT)
    actions:
      $precompute(0, 4):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000023
      - next_table: 0
      - set $tmp44, 255
    default_action: $precompute
  ternary_match tbl_count_pkt 5:
    p4: { name: tbl_count_pkt, hidden: true }
    hit: [  tbl_fcmsketch_fcm_action_l1_d2 ]
    miss:  tbl_fcmsketch_fcm_action_l1_d2
    indirect: tbl_count_pkt$tind
  stateful tbl_count_pkt$salu.FcmEgress.num_pkt:
    p4: { name: FcmEgress.num_pkt, size: 1 }
    row: 15
    logical_bus: S
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    home_row: 15
    format: { lo: 32 }
    actions:
      increment_pkt_0:
      - saddu lo, lo, 1
      - output alu_lo
  ternary_indirect tbl_count_pkt$tind:
    row: 1
    bus: 0
    format: { action: 0..0, meter_addr: 1..10 }
    stateful: tbl_count_pkt$salu.FcmEgress.num_pkt(meter_addr, $DEFAULT, $DEFAULT)
    instruction: tbl_count_pkt$tind(action, $DEFAULT)
    actions:
      FcmEgress.count_pkt(0, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000001e
      - next_table: 0
      - tbl_count_pkt$salu.FcmEgress.num_pkt(increment_pkt_0, 0)
    default_action: FcmEgress.count_pkt
stage 1 egress:
  dependency: match
  hash_action tbl_fcmsketch_fcm_action_l1_d2 1:
    p4: { name: tbl_fcmsketch_fcm_action_l1_d2, hidden: true }
    row: 0
    result_bus: 0
    hash_dist:
      1: { hash: 2, mask: 0x7ffff, shift: 3, expand: 7 }
    input_xbar:
      exact group 1: { 32: eg_md.hash_meta_d2(0..18) }
      hash 2:
        16..31: eg_md.hash_meta_d2(0..15)
        39..41: eg_md.hash_meta_d2(16..18)
      hash group 2:
        table: [2]
        seed: 0x0
    gateway:
      name: tbl_fcmsketch_fcm_action_l1_d2-gateway
      row: 0
      bus: 0
      unit: 0
      0x0:  tbl_fcmsketch_fcm_action_l1_d1
      miss:  tbl_fcmsketch_fcm_action_l1_d1
      condition: 
        expression: "true(always hit)"
        true:  tbl_fcmsketch_fcm_action_l1_d1
        false:  tbl_fcmsketch_fcm_action_l1_d1
    next: []
    action_bus: { 104..107 : tbl_fcmsketch_fcm_action_l1_d2$salu.FcmEgress.fcmsketch.sketch_reg_l1_d2(0..31) }
    stateful: tbl_fcmsketch_fcm_action_l1_d2$salu.FcmEgress.fcmsketch.sketch_reg_l1_d2(hash_dist 1, $DEFAULT, $DEFAULT)
    instruction: tbl_fcmsketch_fcm_action_l1_d2($DEFAULT, $DEFAULT)
    actions:
      FcmEgress.fcmsketch.fcm_action_l1_d2(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000022
      - next_table: 0
      - set W18(0..31), tbl_fcmsketch_fcm_action_l1_d2$salu.FcmEgress.fcmsketch.sketch_reg_l1_d2
      - tbl_fcmsketch_fcm_action_l1_d2$salu.FcmEgress.fcmsketch.sketch_reg_l1_d2(fcmsketch_increment_l1_d2, $hash_dist)
    default_action: FcmEgress.fcmsketch.fcm_action_l1_d2
  stateful tbl_fcmsketch_fcm_action_l1_d2$salu.FcmEgress.fcmsketch.sketch_reg_l1_d2:
    p4: { name: FcmEgress.fcmsketch.sketch_reg_l1_d2, size: 524288 }
    row: [ 15, 13, 11, 9, 7, 5 ]
    logical_bus: [ S, O, O, O, O, O ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    home_row: 15
    format: { lo: 8 }
    actions:
      fcmsketch_increment_l1_d2:
      - saddu lo, lo, 1
      - output alu_lo
stage 2 egress:
  dependency: match
  hash_action tbl_fcmsketch_fcm_action_l1_d1 1:
    p4: { name: tbl_fcmsketch_fcm_action_l1_d1, hidden: true }
    row: 0
    result_bus: 0
    hash_dist:
      1: { hash: 2, mask: 0x7ffff, shift: 3, expand: 7 }
    input_xbar:
      exact group 1: { 32: eg_md.hash_meta_d1(0..18) }
      hash 2:
        16..31: eg_md.hash_meta_d1(0..15)
        39..41: eg_md.hash_meta_d1(16..18)
      hash group 2:
        table: [2]
        seed: 0x0
    gateway:
      name: tbl_fcmsketch_fcm_action_l1_d1-gateway
      row: 0
      bus: 0
      unit: 0
      0x0:  fcmsketch_tb_fcm_l1_to_l2_d2
      miss:  fcmsketch_tb_fcm_l1_to_l2_d2
      condition: 
        expression: "true(always hit)"
        true:  fcmsketch_tb_fcm_l1_to_l2_d2
        false:  fcmsketch_tb_fcm_l1_to_l2_d2
    next: []
    action_bus: { 104..107 : tbl_fcmsketch_fcm_action_l1_d1$salu.FcmEgress.fcmsketch.sketch_reg_l1_d1(0..31) }
    stateful: tbl_fcmsketch_fcm_action_l1_d1$salu.FcmEgress.fcmsketch.sketch_reg_l1_d1(hash_dist 1, $DEFAULT, $DEFAULT)
    instruction: tbl_fcmsketch_fcm_action_l1_d1($DEFAULT, $DEFAULT)
    actions:
      FcmEgress.fcmsketch.fcm_action_l1_d1(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000021
      - next_table: 0
      - set W16(0..31), tbl_fcmsketch_fcm_action_l1_d1$salu.FcmEgress.fcmsketch.sketch_reg_l1_d1
      - tbl_fcmsketch_fcm_action_l1_d1$salu.FcmEgress.fcmsketch.sketch_reg_l1_d1(fcmsketch_increment_l1_d1, $hash_dist)
    default_action: FcmEgress.fcmsketch.fcm_action_l1_d1
  stateful tbl_fcmsketch_fcm_action_l1_d1$salu.FcmEgress.fcmsketch.sketch_reg_l1_d1:
    p4: { name: FcmEgress.fcmsketch.sketch_reg_l1_d1, size: 524288 }
    row: [ 15, 13, 11, 9, 7, 5 ]
    logical_bus: [ S, O, O, O, O, O ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    home_row: 15
    format: { lo: 8 }
    actions:
      fcmsketch_increment_l1_d1:
      - saddu lo, lo, 1
      - output alu_lo
stage 3 egress:
  dependency: match
  exact_match fcmsketch_tb_fcm_l1_to_l2_d2 1:
    p4: { name: FcmEgress.fcmsketch.tb_fcm_l1_to_l2_d2, size: 2 }
    p4_param_order: 
      eg_md.result_d2: { type: exact, size: 32, full_size: 32, key_name: "fcm_mdata.result_d2" }
    row: 0
    result_bus: 0
    hash_dist:
      1: { hash: 1, mask: 0xffff, shift: 4 }
    input_xbar:
      exact group 1: { 3: eg_md.hash_meta_d2(3..18) }
      hash 2:
        16..31: eg_md.hash_meta_d2(3..18)
      hash group 1:
        table: [2]
        seed: 0x0
    gateway:
      name: fcmsketch_tb_fcm_l1_to_l2_d2-gateway
      input_xbar:
        exact group 0: { 16: eg_md.result_d2(16..31), 32: eg_md.result_d2(0..15) }
      row: 7
      bus: 0
      unit: 0
      payload_row: 0
      payload_unit: 0
      payload: 0x60001
      format: { action: 0..0, meter_addr: 1..16, meter_pfe: 17..17, meter_type: 18..20 }
      match: { 0: eg_md.result_d2(0..7), 8: eg_md.result_d2(8..15), 16: eg_md.result_d2(16..23), 24: eg_md.result_d2(24..31) }
      0x000000ff:
        next:  fcmsketch_tb_fcm_l1_to_l2_d1
        action: fcmsketch_fcm_action_l2_d2
      miss:
        run_table: true
    hit: [  fcmsketch_tb_fcm_l1_to_l2_d1 ]
    miss:  fcmsketch_tb_fcm_l1_to_l2_d1
    action_bus: { 104..107 : fcmsketch_tb_fcm_l1_to_l2_d2$salu.FcmEgress.fcmsketch.sketch_reg_l2_d2(0..31) }
    stateful: fcmsketch_tb_fcm_l1_to_l2_d2$salu.FcmEgress.fcmsketch.sketch_reg_l2_d2(hash_dist 1, meter_pfe, meter_type)
    instruction: fcmsketch_tb_fcm_l1_to_l2_d2(action, $DEFAULT)
    actions:
      FcmEgress.fcmsketch.fcm_action_l2_d2(1, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: false, reason: uses_hash_dist }
      - handle: 0x20000027
      - next_table_miss:  fcmsketch_tb_fcm_l1_to_l2_d1
      - next_table: 0
      - add W18, fcmsketch_tb_fcm_l1_to_l2_d2$salu.FcmEgress.fcmsketch.sketch_reg_l2_d2, W19
      - fcmsketch_tb_fcm_l1_to_l2_d2$salu.FcmEgress.fcmsketch.sketch_reg_l2_d2(fcmsketch_increment_l2_d2, $hash_dist)
      NoAction(-1, 0):
      - hit_allowed: { allowed: false, reason: user_indicated_default_only }
      - default_only_action: { allowed: true, is_constant: true }
      - handle: 0x20000028
      - next_table_miss:  fcmsketch_tb_fcm_l1_to_l2_d1
    default_only_action: NoAction
  stateful fcmsketch_tb_fcm_l1_to_l2_d2$salu.FcmEgress.fcmsketch.sketch_reg_l2_d2:
    p4: { name: FcmEgress.fcmsketch.sketch_reg_l2_d2, size: 65536 }
    row: [ 15, 13 ]
    logical_bus: [ S, O ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    home_row: 15
    format: { lo: 16 }
    actions:
      fcmsketch_increment_l2_d2:
      - saddu lo, lo, 1
      - output mem_lo
  exact_match fcmsketch_tb_fcm_l1_to_l2_d1 2:
    p4: { name: FcmEgress.fcmsketch.tb_fcm_l1_to_l2_d1, size: 2 }
    p4_param_order: 
      eg_md.result_d1: { type: exact, size: 32, full_size: 32, key_name: "fcm_mdata.result_d1" }
    row: 0
    result_bus: 1
    hash_dist:
      2: { hash: 1, mask: 0xffff, shift: 4 }
    input_xbar:
      exact group 1: { 35: eg_md.hash_meta_d1(3..18) }
      hash 2:
        32..47: eg_md.hash_meta_d1(3..18)
      hash group 1:
        table: [2]
        seed: 0x0
    gateway:
      name: fcmsketch_tb_fcm_l1_to_l2_d1-gateway
      input_xbar:
        exact group 1: { 64: eg_md.result_d1 }
      row: 0
      bus: 0
      unit: 0
      payload_row: 0
      payload_unit: 1
      payload: 0x60001
      format: { action: 0..0, meter_addr: 1..16, meter_pfe: 17..17, meter_type: 18..20 }
      match: { 0: eg_md.result_d1(0..7), 8: eg_md.result_d1(8..15), 16: eg_md.result_d1(16..23), 24: eg_md.result_d1(24..31) }
      0x000000ff:
        next:  fcmsketch_tb_fcm_l2_to_l3_d2
        action: fcmsketch_fcm_action_l2_d1
      miss:
        run_table: true
    hit: [  fcmsketch_tb_fcm_l2_to_l3_d2 ]
    miss:  fcmsketch_tb_fcm_l2_to_l3_d2
    action_bus: { 112..115 : fcmsketch_tb_fcm_l1_to_l2_d1$salu.FcmEgress.fcmsketch.sketch_reg_l2_d1(0..31) }
    stateful: fcmsketch_tb_fcm_l1_to_l2_d1$salu.FcmEgress.fcmsketch.sketch_reg_l2_d1(hash_dist 2, meter_pfe, meter_type)
    instruction: fcmsketch_tb_fcm_l1_to_l2_d1(action, $DEFAULT)
    actions:
      FcmEgress.fcmsketch.fcm_action_l2_d1(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: false, reason: uses_hash_dist }
      - handle: 0x20000024
      - next_table_miss:  fcmsketch_tb_fcm_l2_to_l3_d2
      - next_table: 0
      - add W16, fcmsketch_tb_fcm_l1_to_l2_d1$salu.FcmEgress.fcmsketch.sketch_reg_l2_d1, W17
      - fcmsketch_tb_fcm_l1_to_l2_d1$salu.FcmEgress.fcmsketch.sketch_reg_l2_d1(fcmsketch_increment_l2_d1, $hash_dist)
      NoAction(-1, 0):
      - hit_allowed: { allowed: false, reason: user_indicated_default_only }
      - default_only_action: { allowed: true, is_constant: true }
      - handle: 0x20000025
      - next_table_miss:  fcmsketch_tb_fcm_l2_to_l3_d2
    default_only_action: NoAction
  stateful fcmsketch_tb_fcm_l1_to_l2_d1$salu.FcmEgress.fcmsketch.sketch_reg_l2_d1:
    p4: { name: FcmEgress.fcmsketch.sketch_reg_l2_d1, size: 65536 }
    row: [ 7, 5 ]
    logical_bus: [ S, O ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2 ]
    home_row: 7
    format: { lo: 16 }
    actions:
      fcmsketch_increment_l2_d1:
      - saddu lo, lo, 1
      - output mem_lo
stage 4 egress:
  dependency: match
  exact_match fcmsketch_tb_fcm_l2_to_l3_d2 1:
    p4: { name: FcmEgress.fcmsketch.tb_fcm_l2_to_l3_d2, size: 2 }
    p4_param_order: 
      eg_md.result_d2: { type: exact, size: 32, full_size: 32, key_name: "fcm_mdata.result_d2" }
    row: 0
    result_bus: 0
    hash_dist:
      1: { hash: 2, mask: 0x1fff, shift: 5 }
    input_xbar:
      exact group 1: { 16: eg_md.hash_meta_d2(16..18), 102: eg_md.hash_meta_d2(6..15) }
      hash 2:
        16..25: 0
        26..28: eg_md.hash_meta_d2(16..18)
      hash 3:
        16..25: eg_md.hash_meta_d2(6..15)
        26..28: 0
      hash group 2:
        table: [2, 3]
        seed: 0x0
    gateway:
      name: fcmsketch_tb_fcm_l2_to_l3_d2-gateway
      input_xbar:
        exact group 1: { 64: eg_md.result_d2 }
      row: 0
      bus: 0
      unit: 0
      payload_row: 0
      payload_unit: 0
      payload: 0xc001
      format: { action: 0..0, meter_addr: 1..13, meter_pfe: 14..14, meter_type: 15..17 }
      match: { 0: eg_md.result_d2(0..7), 8: eg_md.result_d2(8..15), 16: eg_md.result_d2(16..23), 24: eg_md.result_d2(24..31) }
      0x000100fd:
        next:  fcmsketch_tb_fcm_l2_to_l3_d1
        action: fcmsketch_fcm_action_l3_d2
      miss:
        run_table: true
    hit: [  fcmsketch_tb_fcm_l2_to_l3_d1 ]
    miss:  fcmsketch_tb_fcm_l2_to_l3_d1
    stateful: fcmsketch_tb_fcm_l2_to_l3_d2$salu.FcmEgress.fcmsketch.sketch_reg_l3_d2(hash_dist 1, meter_pfe, meter_type)
    instruction: fcmsketch_tb_fcm_l2_to_l3_d2(action, $DEFAULT)
    actions:
      FcmEgress.fcmsketch.fcm_action_l3_d2(1, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: false, reason: uses_hash_dist }
      - handle: 0x2000002b
      - next_table_miss:  fcmsketch_tb_fcm_l2_to_l3_d1
      - next_table: 0
      - fcmsketch_tb_fcm_l2_to_l3_d2$salu.FcmEgress.fcmsketch.sketch_reg_l3_d2(fcmsketch_increment_l3_d2, $hash_dist)
      NoAction(-1, 1):
      - hit_allowed: { allowed: false, reason: user_indicated_default_only }
      - default_only_action: { allowed: true, is_constant: true }
      - handle: 0x2000002c
      - next_table_miss:  fcmsketch_tb_fcm_l2_to_l3_d1
    default_only_action: NoAction
  stateful fcmsketch_tb_fcm_l2_to_l3_d2$salu.FcmEgress.fcmsketch.sketch_reg_l3_d2:
    p4: { name: FcmEgress.fcmsketch.sketch_reg_l3_d2, size: 8192 }
    row: 11
    logical_bus: S
    column: [ 0, 1, 2 ]
    maprams: [ 0, 1, 2 ]
    home_row: 11
    format: { lo: 32 }
    actions:
      fcmsketch_increment_l3_d2:
      - add hi, lo, 65789
      - saddu lo, lo, 1
      - output alu_hi
  exact_match fcmsketch_tb_fcm_l2_to_l3_d1 2:
    p4: { name: FcmEgress.fcmsketch.tb_fcm_l2_to_l3_d1, size: 2 }
    p4_param_order: 
      eg_md.result_d1: { type: exact, size: 32, full_size: 32, key_name: "fcm_mdata.result_d1" }
    row: 0
    result_bus: 1
    hash_dist:
      2: { hash: 2, mask: 0x1fff, shift: 5 }
    input_xbar:
      exact group 2: { 6: eg_md.hash_meta_d1(6..18) }
      hash 4:
        32..44: eg_md.hash_meta_d1(6..18)
      hash group 2:
        table: [4]
        seed: 0x0
    gateway:
      name: fcmsketch_tb_fcm_l2_to_l3_d1-gateway
      input_xbar:
        exact group 0: { 16: eg_md.result_d1(16..31), 32: eg_md.result_d1(0..15) }
      row: 7
      bus: 0
      unit: 0
      payload_row: 0
      payload_unit: 1
      payload: 0xc001
      format: { action: 0..0, meter_addr: 1..13, meter_pfe: 14..14, meter_type: 15..17 }
      match: { 0: eg_md.result_d1(0..7), 8: eg_md.result_d1(8..15), 16: eg_md.result_d1(16..23), 24: eg_md.result_d1(24..31) }
      0x000100fd:
        next:  END
        action: fcmsketch_fcm_action_l3_d1
      miss:
        run_table: true
    hit: [  END ]
    miss:  END
    stateful: fcmsketch_tb_fcm_l2_to_l3_d1$salu.FcmEgress.fcmsketch.sketch_reg_l3_d1(hash_dist 2, meter_pfe, meter_type)
    instruction: fcmsketch_tb_fcm_l2_to_l3_d1(action, $DEFAULT)
    actions:
      FcmEgress.fcmsketch.fcm_action_l3_d1(1, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: false, reason: uses_hash_dist }
      - handle: 0x20000029
      - next_table_miss:  END
      - next_table: 0
      - fcmsketch_tb_fcm_l2_to_l3_d1$salu.FcmEgress.fcmsketch.sketch_reg_l3_d1(fcmsketch_increment_l3_d1, $hash_dist)
      NoAction(-1, 2):
      - hit_allowed: { allowed: false, reason: user_indicated_default_only }
      - default_only_action: { allowed: true, is_constant: true }
      - handle: 0x2000002a
      - next_table_miss:  END
    default_only_action: NoAction
  stateful fcmsketch_tb_fcm_l2_to_l3_d1$salu.FcmEgress.fcmsketch.sketch_reg_l3_d1:
    p4: { name: FcmEgress.fcmsketch.sketch_reg_l3_d1, size: 8192 }
    row: 7
    logical_bus: S
    column: [ 0, 1, 2 ]
    maprams: [ 0, 1, 2 ]
    home_row: 7
    format: { lo: 32 }
    actions:
      fcmsketch_increment_l3_d1:
      - add hi, lo, 65789
      - saddu lo, lo, 1
      - output alu_hi


primitives: "waterfall_fcm.prim.json"
dynhash: "waterfall_fcm.dynhash.json"
